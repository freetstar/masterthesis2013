% !Mode:: "TeX:UTF-8"

\chapter[最长公共子序列算法并行化]{最长公共子序列算法并行化}
\section{最长公共子序列算法并行化}

    最长公共子序列算法的本质是动态规划。动态规划旨在把原文体分解为相当简单的自问体来求解复杂问题。动态规划
通常使用于有重叠子问题和最优子结构。

    动态规划在查找具有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次重复解决
这些子问题，它们的结果都逐渐被计算和保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时
结果，因而不会在解决同样的问题时花费不必要的时间. 动态规划只能应用于有最优子结构的问题。最优子结构的本质是局部最优解能够决定全局最优解   

    最长公共子序列问题是寻找两个或者更多的已知数列最长的子序列，即一个数列$S$，如果是两个或者更多已知数列
的公共子序列，且是所有符合此条件序列中最长的，则$S$被称为已知序列的最长公共子序列 


\section{算法}
用动态规划的方法解决 最长公共子序列问题的方法如下，以两个数列$X,Y$为例:

设又二维数组$f[i][j]$表示X的i位和Y的j位之前的 最长公共子序列的长度，则有：
    $f[1][1]=same(1,1)$

    $f[i][j]=max{f[i-1][j-1]+same(i,j),f[i-1][j],f[i][j-1]}$

其中same(a,b)表示当X的第a位与Y的第b位完全相同时为"1",否则为"0"

\section{算法代码}

    有数列X,Y,c[i,j]用来存储i，j位置的最优解，b[i,j]用来存储位置

\begin{algorithmic}
    
    \State $m \gets length[x]$
    \State $n \gets length[y]$

    \For {$i \gets 1 , m $}
    \State  $c[i,0] \gets 0 $ 
    \EndFor

    \For {$j \gets 1 , n $}
    \State  $c[j,0] \gets 0 $ 
    \EndFor

    \For{$i \gets 1 , m$}
        \For{$j \gets 1 , n$}
            \If{$x_i == y_j$}
                \State $c[i,j] \gets c[i-1,j-1] +1$
                \State $b[i,j] \gets NW$
            \ElsIf{$c[i-1,j] \ge c[i,j-1]$}
                \State $c[i,j] \gets c[i-1,j]$
                \State $b[i,j] \gets N$
            \Else {}
                \State $c[i,j] \gets c[i,j-1]$
                \State $b[i,j] \gets W$
            \EndIf
        \EndFor{}
    \EndFor{}


\end{algorithmic}
\section{算法代码}

%http://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97
%http://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97
